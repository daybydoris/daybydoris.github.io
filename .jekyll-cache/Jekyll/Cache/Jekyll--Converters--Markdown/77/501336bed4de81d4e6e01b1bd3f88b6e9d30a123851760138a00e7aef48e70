I"	 <p><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">이화여대 반효경 교수님 강의</a>를 듣고 정리한 내용
<br /><br /></p>

<h1 id="프로세스의-개념">프로세스의 개념</h1>

<p><img src="https://user-images.githubusercontent.com/60416981/127729003-cae2fb09-e62a-4f18-a58a-716b86ffb19d.png" alt="image" /></p>

<h2 id="프로세스의-문맥context">프로세스의 문맥(context)</h2>

<blockquote>
  <p>“프로세스는 실행 중인 프로그램을 나타낸다.”</p>
</blockquote>

<blockquote>
  <p>프로세스 문맥이란, 현재 프로세스가 어떤 상태에서 수행되고 있었는지에 대한 정보</p>
</blockquote>

<p><br /></p>

<h3 id="프로세스-문맥에-들어있는-정보">프로세스 문맥에 들어있는 정보</h3>

<ol>
  <li>CPU 수행 상태를 나타내는 하드웨어 문맥</li>
  <li>프로세스의 주소 공간</li>
  <li>프로세스 관련 커널 자료구조
    <ul>
      <li>프로세스 별로 저장</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h3 id="프로세스-문맥이-필요한-이유">프로세스 문맥이 필요한 이유</h3>

<p>현대 운영체제는 시분할 시스템이므로, 프로그램이 CPU제어권을 짧게 가지다가 다른 프로세스에게 넘겨주고, 다시 자기 차례에 넘겨받는 식으로 프로그램을 실행한다.</p>

<p>프로세스 A가 실행되고 있다가 다른 프로세스에 CPU를 넘겨줘야할 때가 왔는데, 프로세스A가 어디까지, 어떻게 실행되고 있었는지를 저장해놓지 않는다면 다음 번에 다시 CPU 제어권을 잡았을 때 처음부터 다시 실행해야할 수도 있다.</p>

<p><br /><br /></p>

<h2 id="프로세스의-상태-process-state">프로세스의 상태 (Process State)</h2>

<p><img src="https://user-images.githubusercontent.com/60416981/127729676-f06e4674-bdad-4578-8556-48e8ddd1b4bc.png" alt="image" /></p>

<p>프로세스의 상태는 <strong>Running</strong>, <strong>Ready</strong>, <strong>Blocked</strong> 의 세가지로 나눠볼 수 있다.</p>

<ul>
  <li>Running
    <ul>
      <li>CPU를 잡고 기계어를 수행 중인 상태</li>
    </ul>
  </li>
  <li>Ready
    <ul>
      <li>CPU를 기다리는 상태 (다른 조건은 모두 만족한 상태)</li>
    </ul>
  </li>
  <li>Blocked
    <ul>
      <li>CPU 제어권이 넘어와도 기계어를 수행할 수 없는 상태</li>
      <li>프로세스 자신이 요청한 작업 (ex. I/O 작업)이 즉시 만족되지 않아 이를 기다리고 있는 상태</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>경우에 따라서는 아래의 상태도 포함하기도 한다.</p>

<ul>
  <li>New
    <ul>
      <li>프로세스가 생성중인 상태</li>
    </ul>
  </li>
  <li>Terminated
    <ul>
      <li>수행이 끝났지만 약간 정리할 것이 남아있는 상태</li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>

<h3 id="프로세스-상태도">프로세스 상태도</h3>

<p><img src="https://user-images.githubusercontent.com/60416981/127729676-f06e4674-bdad-4578-8556-48e8ddd1b4bc.png" alt="image" /></p>

<p><br /></p>

<h2 id="pcb-process-control-block">PCB (Process Control Block)</h2>

<blockquote>
  <p>커널의 Data 영역에는 각 프로세스의 PCB가 저장된다.</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/60416981/127729805-4918cf8d-4467-4860-9e23-c7d02c329dba.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/60416981/127729836-52cd326d-7431-4c9c-a5f0-fee7de89298b.png" alt="image" /></p>

<ul>
  <li>PCB : 운영체제가 각 프로세스를 관리하기 위해 프로세스 별로 저장하는 정보</li>
</ul>

<p><br /></p>

<p>PCB는 다음과 같이 구성된다.</p>

<ol>
  <li>OS가 관리 상 사용하는 정보
    <ul>
      <li>Process state, Process ID</li>
      <li>스케줄링 정보, 우선순위</li>
    </ul>
  </li>
  <li>CPU 수행 관련 하드웨어 값
    <ul>
      <li>Program counter 정보</li>
      <li>Register에 어떤 기계어를 넣고 수행 중이었는지에 대한 정보</li>
    </ul>
  </li>
  <li>메모리 관련
    <ul>
      <li>code, data, stack이 메모리 어디에 위치해있는지에 대한 정보</li>
    </ul>
  </li>
  <li>파일 관련
    <ul>
      <li>프로세스가 open하고 있는 파일 정보</li>
    </ul>
  </li>
</ol>

<p><br /><br /></p>

<h2 id="문맥-교환-context-switch">문맥 교환 (Context Switch)</h2>

<blockquote>
  <p>CPU가 한 프로세스에서 다른 프로세스로 넘어가는 과정</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/60416981/127729985-1708163d-0b98-4b19-ac62-8ac2a765651d.png" alt="image" /></p>

<p>CPU가 다른 프로세스로 넘어갈 때 운영체제는 다음을 수행한다.</p>

<ul>
  <li>CPU에서 실행 중이던 프로세스의 상태를 그 프로세스의 PCB에 저장</li>
  <li>CPU를 새롭게 넘겨받는 프로세스의 상태를 그 프로세스의 PCB를 읽어옴</li>
</ul>

<p>(1)
CPU 제어권이 운영체제로 넘어가는 것 자체가 문맥 교환이 아니다.</p>

<p><strong>하나의 프로세스에서 다른 프로세스</strong>로 문맥이 넘어가는 경우를 문맥 교환이라고 한다.</p>

<p>이 경우에도 일부 문맥을 PCB에 저장하긴 함.</p>

<p><br /></p>

<p>(2) timer interrupt 처럼 다른 프로세스로 cpu 제어권을 넘겨야하는 경우,</p>

<p>I/O 작업처럼 시간이 오래 걸리는 작업을 요청했을 경우는 문맥교환이 일어난다.</p>

<p><br /><br /></p>

<h1 id="큐queue">큐(Queue)</h1>

<ul>
  <li>Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합 (Ready Queue, Device Queue에 있는 프로세스 포함)</li>
  <li>Ready Queue</li>
  <li>Device Queue</li>
</ul>

<p><br /></p>

<h2 id="스케줄러-scheduler">스케줄러 (Scheduler)</h2>
<p><img src="https://user-images.githubusercontent.com/60416981/150341821-e7a7bbe6-c591-4ec9-ae15-f379d4e23696.png" alt="image-20210910231735984" /></p>
<ul>
  <li><strong>Short-term scheduler</strong> (단기 스케줄러 / CPU scheduler)
    <ul>
      <li>다음번에 어떤 프로세스에 <strong>CPU 제어권</strong>을 줄지를 결정</li>
    </ul>
  </li>
  <li><strong>Long-term scheduler</strong> (장기 스케줄러 / job scheduler)
    <ul>
      <li>시작된 프로세스 중 어떤 것에 <strong>메모리</strong>를 할당해 <strong>ready queue</strong>로 보낼지 결정</li>
      <li>메모리에 프로그램 몇 개를 올려놓을지 (<strong>degree of Multiprogramming</strong>) 결정</li>
      <li>보통 우리가 사용하는 <strong>time sharing system에는 장기 스케줄러가 없음</strong>. 무조건 ready 상태로 들어감.</li>
    </ul>
  </li>
  <li><strong>Medium-term scheduler</strong> (중기 스케줄러 / Swapper)
    <ul>
      <li>메모리에 너무 많은 프로그램이 올라가있으면 일부 프로그램을 메모리에서 디스크로 쫓아냄.</li>
      <li><strong>degree of Multiprogramming</strong> 제어</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="프로세스의-상태-2">프로세스의 상태 2</h2>

<p><img src="https://user-images.githubusercontent.com/60416981/150341890-57cd52b4-f39d-4220-8f91-ae4ab1442aa6.png" alt="image-20210910232841945" /></p>

<ul>
  <li>중기 스케줄러에 의해 쫓겨난 프로세스는 Suspended 상태가 됨.</li>
  <li>blocked와 suspended를 구분해야함.</li>
</ul>

<p><br /></p>

<h3 id="사용자-프로그램-관점에서의-프로세스-상태도">사용자 프로그램 관점에서의 프로세스 상태도</h3>
<p><img src="https://user-images.githubusercontent.com/60416981/150341971-57108bed-6036-4dfe-b92f-526cd80369bc.png" alt="image-20210910233528656" /></p>

<p>Running 상태를 두가지로 나눔</p>

<ul>
  <li>user mode : 프로그램 자체의 코드를 실행하는 상태</li>
  <li>monitor mode: system call, interrupt 등 운영체제 커널의 코드가 실행되고 있는 상태에도 프로그램이 running하고 있다고 간주함.</li>
</ul>

<h1 id="참고">참고</h1>

<p>https://zangzangs.tistory.com/108</p>

:ET