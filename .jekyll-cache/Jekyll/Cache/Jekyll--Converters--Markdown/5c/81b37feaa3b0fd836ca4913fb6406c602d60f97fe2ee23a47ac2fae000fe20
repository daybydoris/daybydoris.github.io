I"<p><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">이화여대 반효경 교수님 강의</a>를 듣고 정리한 내용
<br /><br /></p>

<h2 id="동기식-입출력과-비동기식-입출력">동기식 입출력과 비동기식 입출력</h2>

<p><img src="https://user-images.githubusercontent.com/60416981/150636894-cee26352-80c4-406e-8543-40114aa8d0f2.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/60416981/150636908-beda616f-015d-43b7-b242-5e0acd6c980d.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/60416981/150636912-3460b0e0-8932-47fa-9849-f76495a20e99.png" alt="image" /></p>

<ol>
  <li>동기식 입출력
    <ul>
      <li>I/O 요청 후, <strong>입출력 작업이 다 완료되고 난 후</strong>에야 CPU 제어권이 사용자 프로그램에 넘어가는 것</li>
    </ul>
  </li>
  <li>비동기식 입출력
    <ul>
      <li>I/O 요청 후, <strong>입출력 작업이 다 완료되지 않아도</strong> CPU 제어권이 사용자 프로그램에게 넘어가서 다른 작업을 할 수 있음</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h1 id="스레드-thread">스레드 (Thread)</h1>

<blockquote>
  <p>스레드: 프로세스 내부의 CPU 수행 단위</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/60416981/150636924-d916a898-9f1c-4dd0-9f9b-bec7dfb6a96a.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/60416981/150636932-3a493dfa-eef7-4abc-b64f-c2c77d6bbc61.png" alt="image" /></p>

<p>서로 공유할 수 있는 것은 모두 공유하고 cpu 수행과 관련된 정보는 각각 저장함.</p>

<ul>
  <li>스레드가 동료 스레드과 공유하는 부분 (=task)
    <ul>
      <li>code</li>
      <li>data</li>
      <li>os resources</li>
    </ul>
  </li>
  <li>스레드 각자가 개별로 가지고 있는 정보 (구성)
    <ul>
      <li>program counter - 어떤 부분을 수행하고 있었는지 가리킴</li>
      <li>register set</li>
      <li>stack space</li>
    </ul>
  </li>
  <li>스레드는 <strong>lightweight process</strong> 라고도 한다. &lt;-&gt; 스레드를 하나만 가지고 있는 heavyweight process</li>
</ul>

<h2 id="스레드의-장점">스레드의 장점</h2>

<p><img src="https://user-images.githubusercontent.com/60416981/150636940-d4e30ac0-d73a-4e60-ad45-4c3a00d7f2f0.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/60416981/150636953-97573104-5abb-46c7-be6a-07bb82b9f9ed.png" alt="image" /></p>

<ul>
  <li><strong>응답성</strong>(Responsiveness): 한 스레드가 blocked 여도 다른 스레드는 running 하여 빠른 처리를 할 수 있다.
    <ul>
      <li>ex) 웹 브라우저는 멀티 스레드이므로, 한 스레드는 서버와 통신을 해서 웹페이지 리소스를 다운받는 동안(일종의 I/O 작업, blocked) 이미 다운받은 리소스를 화면에 표시(running) 해줄 수 있다. 사용자가 좀 더 빠르게 처리된다고 느낄 수 있다.</li>
    </ul>
  </li>
  <li><strong>자원공유</strong>: 다중 스레드가 동일한 일을 수행하여 <strong>높은 처리율</strong>과 <strong>성능 향상</strong></li>
  <li><strong>경제성</strong>
    <ul>
      <li>프로세스 하나 만드는 것보다, 프로세스 내부에 스레드를 하나 만드는 것이 오버헤드가 적다.</li>
      <li>다른 프로세스로 문맥 교환하는 것보다, 프로세스 내부에서 스레드들끼리 switching되는 것이 오버헤드가 적다.</li>
    </ul>
  </li>
  <li>멀티 프로세서 환경에서의 효율성
    <ul>
      <li>각각의 스레드가 다른 프로세서에서 병렬적으로 실행됨</li>
    </ul>
  </li>
</ul>

<h2 id="스레드의-구현-방법">스레드의 구현 방법</h2>

<p><img src="https://user-images.githubusercontent.com/60416981/150636959-cf9ed305-2f0e-4bee-9e31-77cc6e405b08.png" alt="image" /></p>

<ul>
  <li>커널 스레드
    <ul>
      <li>커널이 스레드가 여러개인 것을 알고 있음</li>
    </ul>
  </li>
  <li>유저 스레드
    <ul>
      <li>커널은 스레드가 여러 개인 것을 모르고, 사용자 프로그램 자체적으로 스레드를 여러 개 구현</li>
    </ul>
  </li>
</ul>
:ET