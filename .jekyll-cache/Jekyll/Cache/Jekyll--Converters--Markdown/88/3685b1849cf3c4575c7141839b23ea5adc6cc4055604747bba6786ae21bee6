I" <p><a href="http://www.kocw.net/home/search/kemView.do?kemId=1226304">이화여대 반효경 교수님 강의</a>를 듣고 정리한 내용
<br /><br /></p>

<h1 id="운영체제의-구조">운영체제의 구조</h1>

<p><img src="https://user-images.githubusercontent.com/60416981/150637630-75b6017c-63bf-4570-9240-73a347160af7.png" alt="operating system structure" /></p>

<p><br /></p>

<ul>
  <li>어떤 프로그램에게 CPU 사용권을 줄까? <strong>CPU 스케쥴링</strong></li>
  <li>한정된 메모리를 어떻게 나누어 쓸까? <strong>메모리 관리</strong></li>
  <li>디스크에 들어온 요청을 어떤 순서로 처리할까? <strong>디스크 스케줄링</strong></li>
  <li>느린 입출력장치와 빠른 CPU 간에 어떻게 정보를 주고 받게 할까? <strong>인터럽트, 캐싱</strong></li>
  <li>컴퓨터 안에서 실행되는 프로그램들을 어떻게 관리할까? <strong>프로세스 관리</strong></li>
  <li>그외 - <strong>보호 시스템</strong>, <strong>네트워킹</strong>, <strong>명령어 해석기</strong></li>
</ul>

<p><br /><br /></p>

<h1 id="cpu-스케쥴링">CPU 스케쥴링</h1>

<h2 id="1-fcfs-first-come-first-served">1. FCFS (First-Come First-Served)</h2>

<blockquote>
  <p>먼저 요청을 한 프로그램에게 먼저 CPU를 사용하게 해주는 방식</p>
</blockquote>

<ul>
  <li>
    <p>형평성은 있는 것 같지만, 효율적이지 않음.</p>
  </li>
  <li>
    <p>어떤 프로세스가 먼저 도착하느냐에 따라 효율성이 달라짐.<br /></p>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60416981/150637685-780fad9b-b67d-46c1-9802-eb1d6da3fcf4.png" alt="CPU Scheduling" /></p>

<h2 id="2-sjf-shortest-job-first">2. SJF (Shortest-Job-First)</h2>

<blockquote>
  <p>CPU 사용 시간이 가장 짧은 프로세스를 제일 먼저 CPU를 사용하게 해줌</p>
</blockquote>

<ul>
  <li>기아 현상 (Starvation) : 사용시간이 긴 프로세스는 CPU를 사용할 수 없는 상황이 올 수 있음<br /></li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60416981/150637721-10e46419-303c-4df8-8a95-d22cf3e95986.png" alt="SJF" /></p>

<h2 id="3-rr-round-robin">3. RR (Round Robin)</h2>

<blockquote>
  <p>각 프로세스에 동일한 크기의 CPU 할당 시간을 부여하고, 할당시간이 끝나면 해당 프로세스는 CPU 큐의 제일 뒤에 줄을 서게 됨.</p>
</blockquote>

<ul>
  <li>대기 시간이 프로세스의 CPU 사용 시간에 비례함</li>
  <li>어떤 프로세스도 (n-1)*할당시간 이상 기다리지 않음</li>
  <li>프로세스의 사용시간이 긴 경우 계속 CPU 큐 뒤로 가서 줄을 서면 됨.<br /></li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60416981/150637734-e53d36bf-98f2-4c24-ad32-8516de3b3664.png" alt="Round Robin" /></p>

<p><br /><br /></p>

<h1 id="메모리-관리">메모리 관리</h1>

<p><img src="https://user-images.githubusercontent.com/60416981/150637754-1c86bccb-3807-4040-9c47-3e2561f8d26a.png" alt="메모리 관리" /></p>

<p><br /></p>

<h2 id="프로세스가-메모리에-할당되는-순서">프로세스가 메모리에 할당되는 순서</h2>

<ol>
  <li>디스크에 있는 실행파일을 실행시킨다.</li>
  <li>해당 프로그램만이 가지는 논리적인 주소 공간(가상메모리)이 만들어진다.</li>
  <li>이 가상메모리가 dRam(메모리)에 할당된다.</li>
  <li>메모리 공간이 부족할 경우 메모리의 연장공간인 디스크(스왑 메모리)에 프로세스가 저장된다.</li>
</ol>

<blockquote>
  <p>스왑 메모리:  물리메모리가 부족할 경우를 대비해 사용하는 공간. 디스크의 공간을 메모리처럼 사용한다.</p>
</blockquote>

<p><br /><br /></p>

<h2 id="lru-vs-lfu">LRU vs. LFU</h2>

<p><img src="https://user-images.githubusercontent.com/60416981/150640327-0de6e161-5b61-4a7d-847c-1b9114e7d62c.png" alt="LRU vs. LFU" /></p>

<ul>
  <li>메모리에 프로세스가 꽉 찼을 경우 어떤 프로세스를 내보내고 새로운 프로세스를 할당할 것인가?
    <ul>
      <li>과거를 보고 가까운 미래에 사용될 확률이 낮은 프로세스를 내보낸다.</li>
    </ul>
  </li>
  <li>LRU: 가장 오래 전에 참조된 페이지를 삭제 =&gt; 페이지 1</li>
  <li>LFU: 참조 횟수가 가장 적은 페이지를 삭제 =&gt; 페이지 4</li>
  <li>두 방식 모두 단점이 있기 때문에 LRU와 LFU를 보완한 방법이 필요</li>
</ul>

<p><br /><br /></p>

<h1 id="디스크-스케줄링">디스크 스케줄링</h1>

<blockquote>
  <p>먼저 요청이 들어온 순서대로 처리한다면, 디스크 헤드의 이동 거리가 길어진다.</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/60416981/150640332-15f610ca-a85a-47a6-aad9-16efbf0c55cc.png" alt="디스크 스케줄링" /></p>

<p><br /></p>

<h2 id="디스크-스케쥴링의-목표">디스크 스케쥴링의 목표</h2>

<blockquote>
  <p>Seek Time을 줄이고, 디스크 헤드의 이동거리를 줄여 효율성을 극대화하자</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/60416981/150640345-5a7623c0-e687-4f56-ba8c-949fb3268b81.png" alt="디스크 스케줄링의 목표" /></p>

<p><br /></p>

<h2 id="1-fcfs-first-come-first-served-1">1. FCFS (First-Come First-Served)</h2>

<blockquote>
  <p>먼저 요청이 들어온 순서대로 처리</p>
</blockquote>

<ul>
  <li>헤드의 이동거리가 길어 효율성이 떨어져 사용하지 않음!</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60416981/150640362-c1ed23d8-14fc-44ff-b926-17c71402eacc.png" alt="FCFS" /></p>

<p><br /></p>

<h2 id="2-sstf-shortest-seek-time-first">2. SSTF (Shortest Seek Time First)</h2>

<blockquote>
  <p>탐색 시간이 가장 짧은 요청을 먼저 처리</p>
</blockquote>

<ul>
  <li>Starvation 문제 발생</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60416981/150640370-d508cab8-91d4-4eba-a707-7286e58718ff.png" alt="SSTF" /></p>

<p><br /></p>

<h2 id="3-scan">3. SCAN</h2>

<blockquote>
  <p>요청 큐에 상관없이 헤드가 이동하는 길목에 있는 요청을 처리하는 방법</p>
</blockquote>

<ul>
  <li>Starvation 문제가 발생하지 않음</li>
  <li>헤드의 이동 거리가 짧아짐</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60416981/150640376-17a2b67e-b574-410f-95b1-0093f04c944d.png" alt="SCAN" /></p>

<p><br /></p>

<h1 id="저장장치-계층구조과-캐싱caching">저장장치 계층구조과 캐싱(caching)</h1>

<blockquote>
  <p>I/O 장치와 CPU 사이의 속도차이를 완충하기 위해 캐싱을 사용함</p>
</blockquote>

<ul>
  <li>캐싱: 빠른 저장장치에 정보를 복사해놓아 빠르게 가져다쓸 수 있게 하는 것
    <ul>
      <li>처음에는 제일 밑 계층의 디스크에서  파일을 읽어오지만, 다시 요청한다면 중간 단계에 있는 복사본을 사용하면 되기 때문에 시간이 절약됨</li>
      <li>용량이 한정되어 있기 때문에 모든 정보를 복사해놓을 수는 없음</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60416981/150640407-2d34f7f2-0baa-403f-869d-7131aa5da6d5.png" alt="Caching" /></p>

<ul>
  <li>Speed
    <ul>
      <li>위로 올라갈수록 빠르고, 아래로 내려올수록 느림</li>
    </ul>
  </li>
  <li>Cost
    <ul>
      <li>위로 올라갈수록 비싸고, 아래로 내려올수록 저렴함</li>
    </ul>
  </li>
  <li>Volatility (휘발성)
    <ul>
      <li>메모리는 휘발성, 디스크는 비휘발성</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="플래시메모리">플래시메모리</h2>

<p><img src="https://user-images.githubusercontent.com/60416981/150640418-fbc7188e-4f4c-428c-979b-de60f3d59b72.png" alt="플래시메모리" /></p>

<ul>
  <li>플래시메모리의 단점
    <ul>
      <li>데이터 변형이 일어날 가능성이 있음(시간이 지나면 전하가 조금씩 빠져나가므로)</li>
      <li>쓰기 횟수가 제약되어 있음</li>
    </ul>
  </li>
</ul>

:ET