I"V<p><code class="language-plaintext highlighter-rouge">React.PureComponent</code>는 <code class="language-plaintext highlighter-rouge">React.Component</code>와 비슷하다.</p>

<p><code class="language-plaintext highlighter-rouge">React.Component</code>는 <code class="language-plaintext highlighter-rouge">shouldComponentUpdate()</code>를 구현하지 않지만, <code class="language-plaintext highlighter-rouge">React.PureComponent</code>는 props와 state를 이용한 <strong>얕은 비교</strong>를 구현한다는 차이점이 있다.</p>

<h2 id="얕은-비교shallow-compare">얕은 비교(shallow compare)</h2>

<ul>
  <li>equality를 체크하는 것</li>
  <li>숫자가 문자열 같은 scalar 값들을 비교할 때는 <strong>값</strong>을 비교함</li>
  <li>단, <strong>object</strong>를 비교할 때는 attribute가 아니라 <strong>reference를 비교</strong>함
    <ul>
      <li>레퍼런스만 체크하기 때문에 같은 값이 들어있는 object라도 항상 다른값으로 체크하게 됨.</li>
    </ul>
  </li>
</ul>

<h2 id="reactpurecomponent">React.PureComponent</h2>

<ul>
  <li>pureComponent는 shouldComponentUpdate가 이미 적용된 버전의 React.Component이다</li>
  <li>pureComponent는 renderer에서 shouldComponentUpdate를 수행할 때 <strong>shallow compare</strong>를 수행함</li>
  <li>불필요한 state 변화 감지로 인한 <strong>재렌더링을 줄임</strong>으로써 성능 극대화</li>
</ul>

<h2 id="reactpurecomponent를-사용할-수-있는-상황">React.PureComponent를 사용할 수 있는 상황</h2>

<ul>
  <li>state와 props이 <strong>immutable</strong>일 때
    <ul>
      <li>state과 props가 변하지 않음에도 object라서 reference로 다름을 체크해 항상 다르다고 판단되기 때문에</li>
    </ul>
  </li>
  <li>state와 props이 hierarchy 혹은 복잡한 구조를 가지고 있을 때</li>
  <li>sholudComponentUpdate lifecycle을 사용하지 않을 계획일 때</li>
</ul>

<p><br /></p>

<p><a href="https://ko.reactjs.org/docs/react-api.html#reactpurecomponent">React 최상위 API - React</a></p>
:ET